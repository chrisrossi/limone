======
Limone
======

Limone is a library for generating content types from a Colander_ schema.  A
content type is, in this context, a class that implements the structure and
constraints specified by the schema.

.. _Colander: http://docs.pylonsproject.org/projects/colander/dev/


Basic Usage
-----------

The public interface for Limone consists of a single class, `limone.Limone`.
The `limone.Limone` class serves both as a content type factory and as a
registry for the generated content types.  As an example, take the following
Colander schema, taken from the Colander documentation::

    import colander

    class Friend(colander.TupleSchema):
        rank = colander.SchemaNode(colander.Int(),
                                  validator=colander.Range(0, 9999))
        name = colander.SchemaNode(colander.String())

    class Phone(colander.MappingSchema):
        location = colander.SchemaNode(colander.String(),
                                      validator=colander.OneOf(['home', 'work']))
        number = colander.SchemaNode(colander.String())

    class Friends(colander.SequenceSchema):
        friend = Friend()

    class Phones(colander.SequenceSchema):
        phone = Phone()

    class Person(colander.MappingSchema):
        name = colander.SchemaNode(colander.String())
        age = colander.SchemaNode(colander.Int(),
                                 validator=colander.Range(0, 200))
        friends = Friends()
        phones = Phones()

The simplest way to generate a `Person` content type would be to create a
global intance of `limone.Limone` and then use the `content_schema` decorator::

    import colander
    from limone import Limone

    limone = Limone()

    ... <elided for brevity>

    @limone.content_schema
    class Person(colander.MappingSchema):
        name = etc...

Instances of Person can then be created in the usual way::

    jack = Person(
        name='Jack',
        age=52,
        friends=[
            (1, 'Fred'),
            (2, 'Barney')
        ],
        phones=[
            {'location': 'home',
             'number': '555-1212'},
        ])

Assigning a value to an attribute triggers Colander schema validation.  For
example, when a value of `300` is assigned to `age`::

    jack.age = 300

A `colander.Invalid` exception is raised::

    colander.Invalid: {'age': u'300 is greater than maximum value 200'}

When instantiating a content type, values for all required attributes must be
provided::

    fred = Person()

Raises::

    colander.Invalid: {'age': u'Required', 'name': u'Required'}


Decorating a Class With a Schema
--------------------------------

In some cases you might want to define a class separately from its schema.  For
this you can use the `content_type` decorator.  Let's say that instead of
turning the `Person` schema into a content type directly, we have an `HRPerson`
class which extends a hypothetical `HRRecord` class that we want to use for
our content type::

    @limone.content_type(Person)
    class HRPerson(HRRecord):
        pass

    fred = HRPerson(name='Fred', age=54)

**NOTE** The decorated class must have a no-arg constructor.


Creating a Content Type Imperatively
------------------------------------

The above examples use a declarative style for creating content types. Using
the `add_content_type` method, we can also generate new content types
imperatively. Assuming `HRPerson` has been defined as a class, the example
above could have been written::

    content_type = limone.add_content_type('Person', Person, bases=(HRPerson,))
    fred = content_type(name='Joe', age=54)

The full signature for the `add_content_type` method is::

    add_content_type(name, schema, module=None, bases=(object,))

+ The value of the `name` parameter will be assigned to the `__name__`
  attribute of the generated class and will also be used as the key for looking
  up the content type later in the registry. (See `Using a Limone Instance as
  a Registry`_.)

+ `schema` is the Colander schema to use to generate the class.

+ `module`, if specified, will be used to set the `__module__` attribute of
  the generated class. If `module` is None and an import hook is being used,
  then the value for `module` passed to `hook_import` will be used. (See `Using
  the Import Hook`_.)

+ `bases` can be specified as a tuple of types that are the superclasses for
  the generated classes.  **NOTE** The first base class must have a no-arg
  constructor.


Using a Limone Instance as a Registry
-------------------------------------

A `Limone` instance acts as a registry.  Content types which are generated by
a `Limone` instance can be retrieved using the `get_content_type` method::

    content_type = limone.get_content_type('Person')
    joe = content_type(name='Joe', age=54)

A tuple of all of the registered content types can be retrieved using the
`get_content_types` method::

    for content_type in limone.get_content_types():
        print content_type.__name__, content_type

Prints:

    Person <class 'Person'>


Using the Import Hook
---------------------

In the above two declarative examples, because types were being generated at
module scope, they can be imported using the standard Python import mechanism.
For content types that are generated imperatively, however, there may not be a
global name that can be used to import the type.  This would definitely be the
case in an application that generated content types from schemas that were
generated at runtime through configuration or user input.  This can lead to
difficulties--pickling, for example, does not work if the class can't be found
by Python's import mechanism.  Using the imperative example from earlier, let's
see what happens when we try to pickle and then unpickle an instance of the
`Person` content type::

    import pickle

    content_type = limone.add_content_type(
        'Person', PersonSchema, bases=(HRPerson,))
    fred = content_type(name='Joe', age=54)
    fred2 = pickle.loads(pickle.dumps(fred))
    assert fred is not fred2
    assert fred.serialize() == fred2.serialize()

We get this exception::

    pickle.PicklingError: Can't pickle <class 'Person'>: it's not found as __main__.Person

What we can do, though, is hook Python's import mechanism so that Python can
look up the content type in our Limone instance::

    import pickle

    limone.hook_import()

    content_type = limone.add_content_type(
        'Person', PersonSchema, bases=(HRPerson,))
    fred = content_type(name='Joe', age=54)
    fred2 = pickle.loads(pickle.dumps(fred))
    assert fred is not fred2
    assert fred.serialize() == fred2.serialize()

    limone.unhook_import()

The pickle and unpickle operations are now successful because pickle is able
to look up the type using Python's import mechanism.

The signature for `hook_import` is::

    hook_import(module='__limone__')

The `hook_import` method inserts an object into `sys.meta_path` that can look
up content types in the Limone registry.  If it is going to be used,
`hook_import` *must be called before generating any content types*.  The
`module` parameter is used to set the `__module__` attribute on generated
content types.  This will also be used by the import hook to identify the types
that it is able to import.  Using the default value for `module`, with the
import hook in place, we see that we can import imperatively generated content
types in the standard Pythonic way::

    from __limone__ import Person
    fred = Person(name='Fred', age=54)

The default value for `module` should not be used if you expect that an
application will use more than one Limone instance inside of a single process.
In this case, a different value of `module` should be used for each instance so
that each instance only tries to find content types in its own registry.

The `unhook_import` method cleans up a previously made import hook, returning
`sys.meta_path` to its previous state.


Using Colander`s Serialization/Deserialization
----------------------------------------------

Instances of a content type can be serialized using Colander's serialization::

    jack = Person(
        name='Jack',
        age=52,
        friends=[
            (1, 'Fred'),
            (2, 'Barney')
        ],
        phones=[
            {'location': 'home',
             'number': '555-1212'},
        ])

    from pprint import pprint
    pprint(jack.serialize())

Produces this output::

    {'age': '52',
     'friends': [('1', u'Fred'), ('2', u'Barney')],
     'name': u'Jack',
     'phones': [{'location': u'home', 'number': u'555-1212'}]}

Note that Colander's serialization is a kind of intermediate format.  All
scalar values are serialized to strings, but sequences, tuples and mappings
are returned as lists, tuples and dicts, respectively.  This intermediate form
is easily fed into other serializers, like json, to produce a serialized
byte sequence.

Instances can be instantiated via Colander's deserialization::

    jack = Person.deserialize(
        {'age': '52',
         'friends': [('1', u'Fred'), ('2', u'Barney')],
         'name': u'Jack',
         'phones': [{'location': u'home', 'number': u'555-1212'}]})

Deserialization can also be used to update an existing instance::

    jack.deserialize_update({'age': '53'})

